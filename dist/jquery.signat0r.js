// Generated by CoffeeScript 1.7.1
(function() {
  var CleanRenderer, CubicRenderer, DebugRenderer, Point, Renderer, Sampler, Signat0r, Utils, VariableRenderer,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  Utils = {
    findPosition: function(elem) {
      var leftPos, topPos;
      leftPos = topPos = 0;
      if (elem.offsetParent) {
        while (true) {
          leftPos += elem.offsetLeft;
          topPos += elem.offsetTop;
          if (!(elem = elem.offsetParent)) {
            break;
          }
        }
      }
      return [leftPos, topPos];
    },
    rangeCap: function(val, min, max) {
      if (val < min) {
        return min;
      }
      if (val > max) {
        return max;
      }
      return val;
    },
    curveThroughPoints: function(ctx, points, z, angleFactor, debug) {
      var C, a, aPt, aX, aY, b, bPt, bX, bY, c, cPt, controlAngle, controlDist, controlPts, controlScaleFactor, cos, cp1, cp2, i, old, p, p0, p1, p2, rX, rY, theta, _i, _j, _ref, _ref1;
      if (z == null) {
        z = 0.5;
      }
      if (angleFactor == null) {
        angleFactor = 0.75;
      }
      if (debug == null) {
        debug = false;
      }
      p = points.slice(0);
      if (p.length < 2) {
        return;
      }
      if (p.length === 2) {
        ctx.beginPath();
        ctx.moveTo(p[0].x, p[0].y);
        ctx.lineTo(p[1].x, p[1].y);
        ctx.stroke();
        return;
      }
      z = Utils.rangeCap(z, 0, 1) || 0.5;
      angleFactor = Utils.rangeCap(angleFactor, 0, 1);
      controlPts = [];
      for (i = _i = 1, _ref = p.length - 1; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
        p0 = p[i - 1];
        p1 = p[i];
        p2 = p[i + 1];
        a = p0.ds(p1);
        b = p1.ds(p2);
        c = p0.ds(p2);
        if (a < 0.001) {
          a = 0.001;
        }
        if (b < 0.001) {
          b = 0.001;
        }
        if (c < 0.001) {
          c = 0.001;
        }
        cos = Utils.rangeCap((a * a + b * b - c * c) / (2 * a * b), -1, 1);
        C = Math.acos(cos);
        aPt = p0.sub(p1);
        bPt = new Point(p1.x, p1.y);
        cPt = p2.sub(p1);
        if (a > b) {
          aPt = aPt.normalize(b);
        } else if (b > a) {
          cPt = cPt.normalize(a);
        }
        aPt = aPt.add(p1);
        cPt = cPt.add(p1);
        aX = bPt.x - aPt.x;
        aY = bPt.y - aPt.y;
        bX = bPt.x - cPt.x;
        bY = bPt.y - cPt.y;
        rX = aX + bX;
        rY = aY + bY;
        if (rX === 0 && rY === 0) {
          rX = bX;
          rY = bY;
        }
        if (aY === 0 && bY === 0) {
          rX = 0;
          rY = 1;
        } else if (aX === 0 && bX === 0) {
          rX = 1;
          rY = 0;
        }
        theta = Math.atan2(rY, rX);
        controlDist = Math.min(a, b) * z;
        controlScaleFactor = C / Math.PI;
        controlDist *= (1 - angleFactor) + angleFactor * controlScaleFactor;
        console.log(controlDist);
        controlAngle = theta + Math.PI / 2;
        cp2 = Point.polar(controlDist, controlAngle).add(p1);
        cp1 = Point.polar(controlDist, controlAngle + Math.PI).add(p1);
        if (cp2.ds(p2) > cp1.ds(p2)) {
          controlPts[i] = [cp2, cp1];
        } else {
          controlPts[i] = [cp1, cp2];
        }
        if (debug) {
          ctx.beginPath();
          old = {
            lineWidth: ctx.lineWidth,
            strokeStyle: ctx.strokeStyle
          };
          ctx.lineWidth = 1;
          ctx.strokeStyle = '#aaa';
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(cp2.x, cp2.y);
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(cp1.x, cp1.y);
          ctx.stroke();
          ctx.lineWidth = old.lineWidth;
          ctx.strokeStyle = old.strokeStyle;
        }
      }
      ctx.beginPath();
      ctx.moveTo(p[0].x, p[0].y);
      ctx.quadraticCurveTo(controlPts[1][0].x, controlPts[1][0].y, p[1].x, p[1].y);
      for (i = _j = 1, _ref1 = p.length - 2; 1 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
        ctx.bezierCurveTo(controlPts[i][1].x, controlPts[i][1].y, controlPts[i + 1][0].x, controlPts[i + 1][0].y, p[i + 1].x, p[i + 1].y);
      }
      ctx.quadraticCurveTo(controlPts[i][1].x, controlPts[i][1].y, p[i + 1].x, p[i + 1].y);
      return ctx.stroke();
    }
  };

  Renderer = (function() {
    function Renderer(context, samples, options) {
      this.context = context;
      this.samples = samples;
      this.options = $.extend({}, options);
    }

    Renderer.prototype.render = function() {
      var sample, _i, _len, _ref;
      _ref = this.samples;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        sample = _ref[_i];
        if (sample.list != null) {
          this.renderPath(sample.list);
        } else {
          this.renderPath(sample);
        }
      }
    };

    Renderer.prototype.renderPath = function(points) {
      throw "must be implemented in sub class";
    };

    return Renderer;

  })();

  DebugRenderer = (function(_super) {
    __extends(DebugRenderer, _super);

    function DebugRenderer() {
      return DebugRenderer.__super__.constructor.apply(this, arguments);
    }

    DebugRenderer.prototype.renderPath = function(points) {
      var last, p, _i, _len, _ref;
      last = points[0];
      this.context.beginPath();
      this.context.arc(last.x, last.y, 5, 0, 2 * Math.PI, false);
      this.context.stroke();
      _ref = points.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        this.context.beginPath();
        this.context.arc(p.x, p.y, 5, 0, 2 * Math.PI, false);
        this.context.stroke();
        this.context.font = '9px Arial';
        this.context.fillText("" + (Math.round(p.ds(last))), p.x, p.y - 10);
        last = p;
      }
    };

    return DebugRenderer;

  })(Renderer);

  CleanRenderer = (function(_super) {
    __extends(CleanRenderer, _super);

    function CleanRenderer() {
      return CleanRenderer.__super__.constructor.apply(this, arguments);
    }

    CleanRenderer.prototype.renderPath = function(points) {
      var curr, last, lastWidth, maxDeltaW, w, _i, _len, _ref;
      if (points.length < 2) {
        return;
      }
      last = points[0];
      lastWidth = this.lineWidth(points[0].ds(points[1]));
      maxDeltaW = 1.5;
      _ref = points.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        curr = _ref[_i];
        w = this.lineWidth(curr.ds(last));
        if (w > lastWidth + maxDeltaW) {
          w = lastWidth + maxDeltaW;
        } else if (w < lastWidth - maxDeltaW) {
          w = lastWidth - maxDeltaW;
        }
        this.renderSegment(curr, last, w);
        lastWidth = w;
        last = curr;
      }
    };

    CleanRenderer.prototype.renderSegment = function(p, q, width) {
      this.context.beginPath();
      this.context.lineWidth = width;
      this.context.moveTo(q.x, q.y);
      this.context.lineTo(p.x, p.y);
      this.context.stroke();
    };

    CleanRenderer.prototype.lineWidth = function(x) {
      return this.options.minStrokeWidth || 2;
    };

    return CleanRenderer;

  })(Renderer);

  VariableRenderer = (function(_super) {
    __extends(VariableRenderer, _super);

    function VariableRenderer() {
      VariableRenderer.__super__.constructor.apply(this, arguments);
      this.options.m = (this.options.minStrokeWidth - this.options.maxStrokeWidth) / (this.options.maxDistance - this.options.minDistance);
    }

    VariableRenderer.prototype.lineWidth = function(x) {
      if (x < this.options.minDistance) {
        return this.options.maxStrokeWidth;
      }
      if (x > this.options.maxDistance) {
        return this.options.minStrokeWidth;
      }
      return this.options.maxStrokeWidth + this.options.m * (x - this.options.minDistance);
    };

    return VariableRenderer;

  })(CleanRenderer);

  CubicRenderer = (function(_super) {
    __extends(CubicRenderer, _super);

    function CubicRenderer() {
      return CubicRenderer.__super__.constructor.apply(this, arguments);
    }

    CubicRenderer.prototype.renderPath = function(points) {
      console.groupCollapsed('cubic renderer');
      this.context.lineWidth = 3;
      Utils.curveThroughPoints(this.context, points, this.options.cubicZ, this.options.cubicAngle, this.options.debug);
      return console.groupEnd();
    };

    return CubicRenderer;

  })(Renderer);

  $.extend(Renderer, {
    renderers: {
      debug: DebugRenderer,
      clean: CleanRenderer,
      variable: VariableRenderer,
      cubic: CubicRenderer
    }
  });

  Point = (function() {
    Point.ZERO = new Point(0, 0);

    Point.UNIT = new Point(Math.SQRT1_2, Math.SQRT1_2);

    Point.polar = function(length, angle) {
      var x, y;
      x = Math.cos(angle) * length;
      y = Math.sin(angle) * length;
      return new Point(x, y);
    };

    function Point(x, y) {
      this.x = x;
      this.y = y;
    }

    Point.prototype.ds = function(other) {
      var dx, dy;
      dx = Math.pow(this.x - other.x, 2);
      dy = Math.pow(this.y - other.y, 2);
      return Math.sqrt(dx + dy);
    };

    Point.prototype.add = function(other) {
      if (other.x === 0 && other.y === 0) {
        return this;
      }
      return new Point(this.x + other.x, this.y + other.y);
    };

    Point.prototype.mul = function(scalar) {
      if (scalar === 1) {
        return this;
      }
      return new Point(this.x * scalar, this.y * scalar);
    };

    Point.prototype.sub = function(other) {
      return this.add(other.mul(-1));
    };

    Point.prototype.length = function() {
      return this.ds(Point.ZERO);
    };

    Point.prototype.unit = function() {
      var l;
      l = this.length();
      return new Point(this.x / l, this.y / l);
    };

    Point.prototype.normalize = function(length) {
      if (length == null) {
        length = 1;
      }
      return this.unit().mul(length);
    };

    Point.prototype.equals = function(other) {
      return this.x === other.x && (this.y = other.y);
    };

    Point.prototype.toString = function() {
      return "(" + this.x + "," + this.y + ")";
    };

    return Point;

  })();

  Sampler = (function() {
    function Sampler(offsetX, offsetY) {
      this.offsetX = offsetX;
      this.offsetY = offsetY;
      this.list = [];
    }

    Sampler.prototype.capture = function(e) {
      return this.list.push(new Point(Math.round(e.clientX - this.offsetX), Math.round(e.clientY - this.offsetY)));
    };

    return Sampler;

  })();

  Signat0r = (function() {
    Signat0r.defaultOptions = {
      minStrokeWidth: 2,
      maxStrokeWidth: 8,
      minDistance: 5,
      maxDistance: 70,
      renderStyle: 'cubic',
      debug: false,
      cropPadding: 5,
      cubicZ: 0.5,
      cubicAngle: 0.75
    };

    function Signat0r(canvas, options) {
      this.canvas = canvas;
      this.options = $.extend({}, Signat0r.defaultOptions, options);
      this.reset();
      this.initHandler();
    }

    Signat0r.prototype.initHandler = function() {
      var self;
      self = this;
      return this.canvas.on('pointerdown', function(e) {
        var x, y, _ref;
        _ref = Utils.findPosition(self.canvas.get(0)), x = _ref[0], y = _ref[1];
        self.samplers[e.originalEvent.pointerId] = new Sampler(x, y);
      }).on('pointermove', function(e) {
        var ctx, sampler;
        if ((sampler = self.samplers[e.originalEvent.pointerId]) == null) {
          return;
        }
        sampler.capture(e.originalEvent);
        ctx = self.context({
          strokeStyle: 'red'
        });
        new CleanRenderer(ctx, [sampler]).render();
      }).on('pointerup', function(e) {
        self.samples.push(self.samplers[e.originalEvent.pointerId]);
        self.samplers[e.originalEvent.pointerId] = null;
        self.render();
      });
    };

    Signat0r.prototype.reset = function() {
      this.samplers = {};
      this.samples = [];
      this.resetCanvas();
    };

    Signat0r.prototype.resetCanvas = function() {
      var c;
      c = this.canvas.get(0);
      c.width = this.canvas.width();
      c.height = this.canvas.height();
    };

    Signat0r.prototype.undo = function() {
      if (this.samples.length) {
        this.samples.pop();
        this.render();
        return true;
      }
      return false;
    };

    Signat0r.prototype.hasStrokes = function() {
      return this.samples.length && this.samples[0].list.length;
    };

    Signat0r.prototype.exportImage = function() {
      var cp, ctx, f, raw, tgt;
      if (!this.hasStrokes()) {
        return;
      }
      tgt = document.createElement('canvas');
      ctx = tgt.getContext('2d');
      cp = this.cropArea(this.options.cropPadding);
      f = window.devicePixelRatio || (1500 / this.canvas.width());
      if (f <= 1) {
        tgt.width = cp.w;
        tgt.height = cp.h;
        raw = this.canvas.get(0).getContext('2d').getImageData(cp.x, cp.y, cp.w, cp.h);
        ctx.putImageData(raw, 0, 0);
      } else {
        tgt.width = f * cp.w;
        tgt.height = f * cp.h;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'bevel';
        ctx.strokeStyle = 'black';
        this.rendererFromOptions(ctx, this.normalizedSamples(f)).render();
      }
      return tgt.toDataURL('image/png');
    };

    Signat0r.prototype.exportSamples = function() {
      return JSON.stringify(this.normalizedSamples());
    };

    Signat0r.prototype.normalizedSamples = function(scale) {
      var cp, offset;
      if (scale == null) {
        scale = 1;
      }
      if (!this.hasStrokes()) {
        return [];
      }
      cp = this.cropArea(this.options.cropPadding);
      offset = new Point(cp.x, cp.y);
      return this.samples.map(function(sample) {
        return sample.list.map(function(point) {
          return point.sub(offset).mul(scale);
        });
      });
    };

    Signat0r.prototype.render = function() {
      var ctx;
      this.resetCanvas();
      this.rendererFromOptions(this.context(), this.samples).render();
      if (this.options.debug) {
        ctx = this.context({
          strokeStyle: 'green'
        });
        new DebugRenderer(ctx, this.samples).render();
      }
    };

    Signat0r.prototype.rendererFromOptions = function(context, samples) {
      var r;
      if (!(r = Renderer.renderers[this.options.renderStyle])) {
        r = CleanRenderer;
      }
      return new r(context, samples, this.options);
    };

    Signat0r.prototype.context = function(options) {
      var ctx;
      if (options == null) {
        options = {};
      }
      ctx = this.canvas.get(0).getContext('2d');
      ctx.lineCap = options.lineCap || 'round';
      ctx.lineJoin = options.lineJoin || 'bevel';
      ctx.lineWidth = options.lineWidth || 1;
      ctx.strokeStyle = options.strokeStyle || 'black';
      return ctx;
    };

    Signat0r.prototype.cropArea = function(padding) {
      var p, sample, xmax, xmin, ymax, ymin, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      if (padding == null) {
        padding = 0;
      }
      _ref = [this.canvas.height(), 0, 0, this.canvas.width()], ymin = _ref[0], xmax = _ref[1], ymax = _ref[2], xmin = _ref[3];
      _ref1 = this.samples;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        sample = _ref1[_i];
        _ref2 = sample.list;
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          p = _ref2[_j];
          if (p.y < ymin) {
            ymin = p.y;
          }
          if (p.x > xmax) {
            xmax = p.x;
          }
          if (p.y > ymax) {
            ymax = p.y;
          }
          if (p.x < xmin) {
            xmin = p.x;
          }
        }
      }
      return {
        x: Math.floor(xmin - padding),
        y: Math.floor(ymin - padding),
        w: Math.ceil(xmax + 2 * padding - xmin),
        h: Math.ceil(ymax + 2 * padding - ymin)
      };
    };

    Signat0r.prototype.debug = function(msg) {
      if (!(this.options.debug && ((typeof console !== "undefined" && console !== null ? console.debug : void 0) != null))) {
        return;
      }
      console.debug("[Signat0r]", msg);
    };

    Signat0r.prototype.setOption = function(which, val) {
      if (this.options[which] != null) {
        this.options[which] = ['minStrokeWidth', 'maxStrokeWidth', 'minDistance', 'maxDistance'].indexOf(which) >= 0 ? parseInt(val, 10) : val;
      } else if (which === 'samples') {
        this.samples = val.map(function(list) {
          var s;
          s = new Sampler();
          s.list = list.map(function(p) {
            return new Point(p.x, p.y);
          });
          return s;
        });
        this.render();
      }
    };

    Signat0r.prototype.getOption = function(which) {
      if (this.options[which] != null) {
        return this.options[which];
      }
    };

    return Signat0r;

  })();

  $.fn.signat0r = function() {
    var args, instance, options, _ref;
    options = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (options == null) {
      options = {};
    }
    if (String(options) === options) {
      instance = this.data('_signat0r-instance');
      return (_ref = instance[options]) != null ? _ref.apply(instance, args) : void 0;
    } else {
      instance = new Signat0r(this, options);
      this.data('_signat0r-instance', instance);
      return this;
    }
  };

}).call(this);
